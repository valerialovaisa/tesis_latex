\documentclass[a4paper,11pt]{article} 

% \documentclass[a4paper,11pt]{book} 

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{graphicx}

\usepackage{colortbl}
\usepackage{color}

\usepackage{hyperref}

\usepackage[margin=1in]{geometry}
\pagestyle{plain}

%\usepackage{fancyhdr} 
%\usepackage{lastpage}
%\usepackage{float} 
%\floatstyle{boxed} 
%\restylefloat{figure} 
%\pagestyle{fancy}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{6}

\definecolor{orange}{RGB}{0,0,255}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
%\title{\textcolor{orange}{Guia Practica Instalación de MinSoc}}
%\author{Gomez,Roberto Pablo - Lovaisa Michelini, Valeria  \\ Universidad Tecnológica Nacional \\ CUDAR }

\begin{document}

%\lhead{\includegraphics[width=1\textwidth]{encab.png}}
%\lfoot{{\includegraphics[width=1\textwidth]{pie.png}}}
%\rfoot{\thepage}

%\maketitle 
%\newpage

\tableofcontents


\newpage

\section{\textcolor{orange}{Introducción}}
\subsection{\textcolor{orange}{Descripción General}}
Descripción por arriba del trabajo. por ejemplo la industria dispone de herramientas que nosotros usamos para un fin determinado.

\subsection{\textcolor{orange}{Objetivos}}
\subsubsection{\textcolor{orange}{Objetivo General}}

Implementar un system on chip OpenSource con un microprocesador embebido Soft-core que soporte un sistema operativo libre , con la finalidad de entregar un sitema integral FPGA-SoC-Sistema Operativo completamente funcional y bajo licencia GPL v2.

\subsubsection{\textcolor{orange}{Objetivo Específico}}
\begin{itemize}
\item Seleccionar, analizar y determinar un microprocesador Sof-Core.
\item Establecer un system on chip Open Source donde poder implementar un Soft-Core.
\item Determinar sistemas operativo con licencia GPL v2 que tengan las prestaciones funcionales adecuadas.
%\item Evaluar, seleccionar una plataforma objetivo un entorno de trabajo  las prestaciones de los Kit de desarrollos con FPGA disponibles en el área de trabajo.
%\item Evaluar, seleccionar y validar las prestaciones de los Kit de desarrollos con FPGA disponibles en el área de trabajo.
%\item Analizar un soft-core que me de las prestaciones funcionales que cumplan de  los requerimientos 
%\ Obtener  completamente funcional sobre un kit de desarrollo XILINX XtremeDSP Starter Platform Spartan 3A DSP 1800.
%\item Implementar un Sistema Operativo eCos sobre un SoC de codigo abierto en el Kit de desarrollo XILINX XtremeDSP Starter Platform Spartan 3A DSP 1800.
%\item Implementar un Sistema Operativo Linux sobre un SoC de codigo abierto en el Kit de desarrollo XILINX XtremeDSP Starter Platform Spartan 3A DSP 1800 .
%\item Probar el adecuado funcionamiento de el sistema global que tenga las  prestaciones funcional  
%tradicionales de diseño
\end{itemize}

\subsection{\textcolor{orange}{Motivación}}

Existe un grupo de cores Sof-Core de código abierto que no están limitados por la tecnología. Los cores destacados de microprocesadores de 32 bits, son los procesadores SPARC LEON OpenRISC 1200 , y el core de LatticeMico32. Usar cores de  codigo abierto,  va unido a una serie de conceptos como:
 \begin {itemize}
\item Flexibilidad. Si el codigo fuente está disponible, los desarrolladores pueden modificar el codigo de acuerdo a sus necesidades.Adémas, se produce un flujo constante de ideas que mejora la calidad del codigo.
\item Fiabilidad y seguridad. Con muchos programadores a la vez escrutando el mismo trabajo, los errores se detectan y corrigen antes, por lo que el producto resultante es mas fiable y eficaz que el comercial.
\item Rapidez de desarrollo. Las actualizaciones y ajustes se realizan a través de una comunicación constante vía Internet.
\item Relación con el usuario. El programador se acerca mucho mas a las necesidades reales de su cliente, y puede crear un producto especifíco para él
 \end {itemize}
 
Obtener un sistema integral de código abierto en donde se tiene código HDL, assembler y C disponible para adaptarse de acuerdo a los requerimientos del proyecto. Ademas de la de la capacidad de migrar de una plataforma a otra. Logrando menor dependencia entre el código fuente y la plataforma objetivo. 
La portabilidad del codigo abierto nos permite implementarlo sobre una ASICs (Application-specific integrated circuit) o con modificaciones menores en cualquier FPGA (Field Programmable Gate Array) de Xilinx, Altera, Lattice, etc. 

Estos tres de los más grandes proveedores de FPGA , Xilinx , Altera y Lattice , ofrecen sus propios micro core RISC de 32bits los dos mayores proveedores de dispositivos FPGA , Altera y Xilinx , proporcionan el micro core Nios y Microblaze, respectivamente. Son micro cores  en donde el codigo fuente RTL no se encuera disponible y solo pueden ser implementados en sus respectivas FPGA.
 
Una de principales ventajas de usar plataformas con FPGA, es que son flexibles asi que pueden adaptarse a diferentes funciones. Los componentes de hardware ofrecen mucho mayor rendimiento que el software equivalente. Los cuellos de botella de procesamiento del sistema pueden identificarse y sustituirse por hardware, de manera que se evita la costosa optimizan del software.

\subsection{\textcolor{orange}{Importancia del Problema}}

En el diseño del sistema embebido se usan diferentes procesos depende del tipo de sistema, el hardware disponible y la organización que desarrolle el sistema. Una de las actividades principales en un proceso de diseño de software es la elección del hardware y del sistema operativo que se efectúa antes del comienzo del software. Ante tal situación , se debe diseñar el software par considerar las restricciones impuestas por las capacidades del hardware.
Los efectos que influyen dichas elecciones comprenden restricciones de de temporización sobre el sistema, limitación en la energía disponible, experiencia del equipo de desarrollo y limites en el costos del sistema entregable.
 
Se está explorando una linea donde se busca dar al diseñador del sistema embebido una solución flexible en la primera etapa de la elección de plataforma. Donde a través del análisis de diferentes plataformas de desarrollo OpenSource y privativas pueda elegir la mejor opción para el tipo de sistema a desarrollar y requerimientos de proceso. 
 
Una vez que se ha elegido la plataforma de ejecucion para el sistema, se ha diseñado una arquitectura de proceso y se a determinado una políticas de planeación, es necesario comprobar que el sistema cumplirá sus con sus requerimientos.

\subsection{\textcolor{orange}{Alcance del Estudio}}

Debido al plazo estipulado para el desarrollo del proyecto, el mismo involucra tres etapas: 

 \begin {itemize}
\item Especificación y Análisis de requerimientos.
\item Implementación.
\item Testing.
 \end {itemize}


%de donde hasta donde vamos a ir
%primero elegimos un micro después lo embebemos en un soc y después le metimos un sistema operativo
\subsection{\textcolor{orange}{Modelo de Desarrollo}}


El modelo de desarrollo a utilizar es el Modelo en Espiral tipificado por Ian Sommerville [2] . El modelo en espiral de ingeniería de software, mostrado en la Ilustración 1, fue originalmente propuesto por Boehm en año 1988, en su artículo A Spiral Model of Software Development and Enhancement. Propuso un marco del proceso de software dirigido por el riesgo. Aquí, el proceso de software se representa como una es espiral, cada ciclo en la espiral representa una fase del proceso de software. Por ende el, ciclo más interno puede relacionarse con la factibilidad del sistema, el siguiente ciclo con la definición de requerimientos, el siguiente ciclo al diseño del sistema, y así sucesivamente.
Cada ciclo del espiral se divide en 4 sectores:
 
\begin {itemize}
\item Establecimiento de objetivo  Se definen objetivos específicos para dicha fase del proyecto. Se identifican restricciones en el proceso y el producto, y se traza un plan detallado de gestión. Se identifican los riesgos del proyecto. Dependiendo de estos riegos, se planean estrategias alternativas
\item Validación y reducción del riesgo  En cada uno de los riesgos identificados del proyecto, se realiza un análisis minucioso. Se dan acciones para reducir el riesgo.
\item Desarrollo y validación  Despues de una evaluacion del riesgo, se elige un modelo de desarrollo para el sistema.
\item Planeción  El proyecto se revisa y se toma una decisión sobre si hay que continuar con otro ciclo de la espiral. Si se opta por continuar, se trazan los planes para la siguente fase del proyecto.
 \end {itemize}mn

Como característica principal de esta metodología es que posee una consideración explícita del riesgo. Informalmente, el riesgo significa sencillamente que algo puede ir mal. Los riegos originan problemas en el proyecto, como los de confección de agendas y excesos en los costos; por lo tanto, la disminución de riegos es una actividad sumamente importante en la gestión del proyecto.
Un ciclo en la espiral comienza con la elaboración de objetivos, como el rendimiento y la funcionalidad. Entonces se enumeran formas alternativas de alcanzar estos objetivos y las restricciones impuestas en cada una de ellas. Cada alternativa se evalúa contra cada objetivo y se identifican las fuentes de riegos del proyecto. El siguiente paso es resolver estos riesgos mediante actividades de recopilación de información como la de detallar más el análisis, la construcción de prototipos y la simulación. Una vez que se han evaluado los riesgos se llevará a cabo cierto desarrollo, seguido de una actividad de planificación para la siguiente fase del proceso.

\subsection{\textcolor{orange}{Metodología}}

Considerando que el objetivo planteado es un desarrollo que se realiza por primera vez, se aplicará un desarrollo experimental y de simulación. La falta de documentación al respecto y al ser un desarrollo de vanguardia son factores que acentúan en esta decisión. Sumado a lo anteriormente dicho, en el laboratorio donde se desarrolla este proyecto no existen antecedentes de trabajos similares.
 
Se utilizó como metodología en este desarrollo el modelo de componentes, donde se define estándares para la implementación, documentación y el despliegue de componentes. 


%\section{\textcolor{orange}{Perspectiva Historica}}
%	\subsection{\textcolor{orange}{El Comienzo de los Microprocesadores}}
%	\subsection{\textcolor{orange}{FPGAs y Microsprocesadores Soft-Core}}
%	\subsection{\textcolor{orange}{Software OpenSource y Libre}}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CAPITULO 2%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textcolor{orange}{FPGA y microprocesadores Soft-Core}}%julius
	\subsection{\textcolor{orange}{FPGAs}}

La fabricación de dispositivos semiconductores es un proceso complicado de plazos largos y costoso. Esto lleva a que los diseños destinados para la  implementacion en chip de silicio tengan poco oportunidad de ser prototipados antes de que comience la producción en grandes volúmenes. Esto supone una gran importancia  en las faces de prueba y verificación de un diseño antes de ser fabricado.

Basándose en la predicción de la ley de Moore donde expresa que aproximadamente cada dos años se duplica el número de transistores en un circuito integrado\cite{Etiqueta01}, Ross Freeman postulo que los transistores serian menos costoso cada año, haciendo asequible la fabricación de chips programables personalizables \cite{Etiqueta03}.
La compañía Xilinx, ofreció su primer chip en 1984 , que contiene arrays celdas lógicas (LCAs) , programables por el usuario en casi cualquier configuración que quisieran. Estos se conocen como Field Programmable Gate Array (FPGAs) .

Las FPGAs desempeñan un papel dual, uno como objetivo final de ejecución en un diseño y otro papel como prototipo para la implmentacion definitiva de un diseño. Su capacidad de reconfigurar el diseño parcial o totalmente para su actualización o corrección de errores tiene un costo relativamente bajo a diferencia del prototipado sobre ASICs.
Actualmente las FPGA cuentan con una gran cantidad de recursos disponibles (Compuertas lógicas , Bloques de RAM) para implementar diseños digitales complejos.

Una desventaja de las FPGA  es debido a la naturaleza inherente de las arquitecturas de FPGA, los diseños implementados en FPGA comparados con una ASICs en general tienen mas area, menos porformance y consumen mas energía.

		\subsubsection{\textcolor{orange}{Arquitectura}}	

Los componentes de una \textit{FPGA} se pueden dividir en cinco grupos:

\begin {itemize}
\item  Bloques lógicos configurables y \textit{Lookup Tables}.
\item  Bloques de entrada y salida.
\item  Bloques multiplicadores
\item  Bloques Manejadores de Clock Digitales.
 \end {itemize}

\begin{figure}[h!]
 \begin{center}
 % \includegraphics[width=0.5\textwidth,keepaspectratio=true]{./images/fpga1a.gif}
  \caption{Componentes de una FPGA}
  \label{fig:esquema}
 \end{center}
\end{figure}

		\subsubsection{\textcolor{orange}{Bloques Lógicos Configurables y Lookup Tables}}
Todas las \textit{FPGA} se basan en arrays de pequeños elementos de lógica digital. Los problemas de lógica digital se descomponen en circuitos lógicos que puedan ser mapeados a uno o más de estas “celdas lógicas” a través de un proceso llamado “technology mapping".

Cada bloque de logica configurable varia de acuerdo a su fabricante, en el caso de Xilinx tienen el nombre Logic cell (LC) contiene una 4 input LUT, un multiplexor y un registro. Se puede configurar la polaridad del clock, el clock enable y la señal de reset.


\begin{figure}[h!]
 \begin{center}
 %\includegraphics[width=0.5\textwidth,keepaspectratio=true]{./images/celda}
  \caption{Componentes de una FPGA}
  \label{fig:esquema}
 \end{center}
\end{figure}

También se encuentran las Lookup Tables, que son elementos lógicos que están compuestos de al menos un registro programable (flip\-flop) y alguna lógica de entrada, que usualmente está implementada como una lookup table de n entradas, donde n es 5 o menos. Estas LUTs son capaces de implementar cualquier función combinacional de sus entradas.

		\subsubsection{\textcolor{orange}{Bloques de Entrada y Salida de propósito general }}

Las FPGAs poseen pines TTL, CMOS, PCI, LVDS y muchos otros que les permiten hacer de interface y convertir muchas tecnologías diferentes. Las FPGAs tienen bloques de I/O dedicados para clocks y resets globales. También incluyen PLL y esquemas para el manejo de clocks permitiendo múltiples dominios del mismo.

Las FPGAs actuales tienen impedancias de I/O configurables,  permiten el uso de resistencias internas terminales cuyos valores pueden ser configurados por el usuario. 


		\subsubsection{\textcolor{orange}{Bloques de Memoria}}

Las FPGAs actuales incorporan memorias on-chip, tales como las SRAM. Estas memorias pueden ser accedidas en forma jerárquica, desde la memoria local de cada celda a la memoria global de los bloques compartidos de memoria. Si bien esto no hace a la esencia de la FPGA, todas hoy en día poseen estos bloques para dar solución al impacto que conlleva utilizar una memoria externa al chip, mayormente soluciona los problemas de latencia.

		\subsubsection{\textcolor{orange}{Multiplicadores}}
Algunas funciones como los multiplicadores son muy lentos si se implementan mediante la conexión de un gran numero de bloques lógicos. Por eso muchas FPGAs incorporan bloques multiplicadores hardware. Estos bloques se encuentran muy cerca de los bloques de RAM embebidos. 
\subsubsection{\textcolor{orange}{Manejadores de Clock Digitales}}
 Se llama clock tree porque la señal de clock principal es ramificada para que alcance a todos los flip-flops.Esta estructura es así para asegurarse que todos los flip flop estén lo mas cerca posible del clock y evitar el problema del skew.El clock tree es implementado usando canales separados de los de propósito general para interconectar los bloques.

		\subsection{\textcolor{orange}{Microprocesadores Soft-Core }}

El avance en la en la tecnología de fabricación de VLSI (Very Large Scale Integratio) a medida que se agregaron más y más transistores,y en consecuencia más y más funciones fueron integradas en un mismo chip, por lo tanto también las capacidades en FPGAs. Grandes diseños de sistemas digitales que fueron sólo para ser implementado como ASICs, luego tuvieron la opción de ser ejecutados en FPGA.

El microprocesador, ya sea como un componente discreto o  como parte de otra lógica en el mismo chip, es una candidato  para ser  implementado en FPGA. Esto introdujo un mayor potencial para la exploración del espacio de diseño haciendo que la logica de computo especifica sea implemetada junto con un microprocesador estándar %\cita{estiqueta20}
		
	\subsubsection{\textcolor{orange}{ IP-Core}}

El diseños de circuitos digitales se dividen normalmente en bloques funcionales, que se refiere como módulos, o \textit{cores}. Un \textit{core} estara formado por sub-bloques que ayudan a poner en práctica su funcionalidad. Los \textit{cores} pueden variar en tamaño hasta el tamaño total de un microprocesador. Un \textit{core} puede ocupar una FPGA entera al ser implementado, mientras que sólo se crea una instancia entre otros en una FPGA más grande o en un ASIC. Los \textit{núcleos} se describen generalmente utilizando un lenguaje de descripción de hardware (HDL) en un nivel de abstracción conocida como registro nivel de transferencia (RTL).

El proceso de tomar la descripción RTL de un diseño y convertirlo en un lista de primitivas o puertas lógicas y las conexiones entre ellos, dejando luego que la  implementación se realice en una tecnología de destino, se conoce como\textit{síntesis}. Analogamente a la compilación de software - que se tiene un programa en un lenguaje de alto nivel, como C, y  es convertido a codigo maquina. 

El resultado de la síntesis, conocida como una \textit{netlist}, está en un nivel de abstracción denominado nivel de la puerta.En pocas palabras, es esta lista de conexiones que se utiliza para su posterior procesamiento en una configuración para FPGA o en un diseño para ASIC.

Los cores pueden ser diseñados por una persona o entidad, los desarrolladores de \textit{cores} y licenciatarios varían en tamaño desde particulares a empresas de miles de millones de dólares. El producto, en este caso se conoce como un \textit{IP core  Intellectual Property Core} el diseño es la propiedad intelectual de los desarrolladores de terceros y la derecho a usarla recibe la licencia del cliente. La \textit{Intellectual Property IP} varia  de  acuerdo a las licencia.

			\paragraph{\textcolor{orange}{ Tipos de IP-Core}}
hard soft y intermedios
%El producto , en este caso se conoce como un núcleo IP (propiedad intelectual a menudocore) en el sentido de que el diseño es la propiedad intelectual de los desarrolladores de terceros y le da derecho a usarlo  recibe la licencia del cliente. Se utilizan los términos IP y el núcleo indistintamente y en combinación para significar la misma cosa .IP puede ser en una variedad de formas cuando licencia . Cuando está en la forma de sintetizable RTL entonces el IP se conoce como un núcleo blando . Si se trata de una forma menos abstraído forma , tal como un formato de un mensaje - diseño listo lista de conexiones o para la fabricación, que se conoce como IP núcleo duro .

\subsection{System on Chip}

La innovación continua en la tecnología de fabricación de semiconductores, ha visto al
disponible "real estate" en los chips de aumento en línea con la predicción de 1965 por Gordon E. Moore. La capacidad de los ingenieros de diseño digital para hacer uso de estos transistores adicionales no ha seguido el ritmo de este incremento en la capacidad de fabricación (21). El tiempo para las necesidades del mercado de estos diseños cadam vez más complejos ha permanecido estático, si no apretado.

Esto ha llevado a la aparición de la industria de núcleo IP compuesta de las empresas especializadas en el desarrollo y concesión de licencias IP a las personas la construcción de sistemas de FPGA o ASIC aplicación.

Esto permite a los equipos de diseño para montar un sistema formado por componentes básicos desarrollados por terceros para implementar el soporte para los protocolos de comunicación estándar, como Ethernet, IIC o SPI, mientras se concentra sus esfuerzos en el diseño de lo que es lo que hace que su diseño único o
particularmente valiosa


 intro,  deferencias entre micros soft y hard. fabricantes.ventajas de uno sobre el otro.
 Ejemplo:
En la industria existe un grupo ligeramente diferente de microprocesadores  Soft-Core , apuntando principalmente al hardware reconfigurable . Tres de los más grandes proveedores de FPGA , Xilinx , Altera y Lattice , ofrecen sus propios núcleos de microprocesadores RISC de 32 bits. Los dos mayores proveedores de dispositivos FPGA , Altera y Xilinx , proporcionan la Nios y Microblaze núcleos , respectivamente. Ellos se consideran hard-core en los que la fuente RTL no se encuentra  disponibles y sólo pueden ser implementadas en sus  Tecnologías FPGA .

Existe un grupo de cores opensource que no están limitados por la tecnología, y
son cores intrínsecamente soft . Los cores mas destacados en esta categoría son los  microprocesadores de 32 bits  SPARC LEON OpenRISC 1200 , y el núcleo LatticeMico32 de la empresa Lattice.

Para el desarrollo de una aplicación reconfigurable existe los micro cores de 32bist que ofrece los proveedores de las FPGA y los micro soft-core opensource disponibles de forma gratuita.

 Sin embargo , cuando se trata de ser capaz de desarrollar y vender un producto a base de estos núcleos , hay consideraciones adicionales sobre la concesión de licencias de los diseños. Estas cuestiones relacionadas con licencias voluntad se discutirá en una sección posterior.
%Las ventajas de un verdadero  sobre un soft-core y hard-core,%\ tienen que ver con la apertura del diseño, y la ausencia de restricciones sobre lo que se puede hacer con la obra. Con un diseño de la fuente verdaderamente abierta existe la opción de personalizar la descripción RTL para implementar la optimización o la funcionalidad deseada . Portabilidad y el producto se refiere al final de su vida también no surgir con la descripción RTL del diseño .


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CAPITULO 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textcolor{orange}{Benchmark}}
Este capitulo lo puse para darle una intro a el estudio de los test que voy a poner en el estudio de los micor soft-core
	\subsection{\textcolor{orange}{Introducción}}
explico un poco para q los uso y en que se usan

En informática , un punto de referencia es el acto de ejecutar un programa de ordenador, un conjunto de programas , u otras operaciones , a fin de evaluar el rendimiento relativo de un objeto , normalmente mediante la ejecución de una serie de pruebas estándar y los ensayos en contra de ella . El término ' benchmark ' también se utiliza sobre todo para los fines de los propios programas de benchmarking elaboradamente diseñados.

Benchmarking se asocia generalmente con la evaluación de las características de rendimiento de hardware , por ejemplo , el rendimiento de punto flotante de funcionamiento de una CPU , pero hay circunstancias en que la técnica también es aplicable al software . Puntos de referencia de software están , por ejemplo, van en contra de los compiladores o sistemas de gestión de bases de datos .

	\subsection{\textcolor{orange}{CPU core benchmarking}}
 
A pesar de que no se corresponde con la forma en que utilizaría un procesador en una aplicación real , a veces es importante aislar el núcleo de la CPU de los otros elementos del procesador y centrarse en un elemento clave. Por ejemplo , es posible que desee tener la capacidad de hacer caso omiso de la memoria y los efectos de E / S y se centran principalmente en la operación de el pipeline. Este es el dominio de CoreMark . CoreMark es capaz de probar la estructura de pipeline básica de un procesador , así como la capacidad de prueba de lectura / escritura de operaciones básicas , operaciones de enteros y operaciones de control

	\subsection{\textcolor{orange}{CoreMark}}

CoreMark es un punto de referencia que tiene como objetivo medir el rendimiento de las unidades centrales de procesamiento ( CPU) utilizados en sistemas embebidos. Fue desarrollado en 2009 por Shay Gal -On en EEMBC y está destinado a convertirse en un estándar de la industria , en sustitución de la referencia Dhrystone anticuada . El código está escrito en código C y contiene las implementaciones de los algoritmos siguientes : procesamiento de lista ( encontrar y ordenar ) , Matrix (matemáticas) manipulación ( operaciones con matrices comunes ) , máquina de estados ( determinar si un flujo de entrada contiene números válidos ) y CRC
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CAPITULO 4%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\textcolor{orange}{Software OpenSource y Libre}}%julius
		\subsection{\textcolor{orange}{Deferencias}}%http://www.slideshare.net/wilberth1594/tesis-alex-8795926,julius
Una interpretación sencilla de lo que se entiende por el término \textit {open source} o \textit{código abierto}, cuando se utiliza en el contexto de la descripción de un programa de software o diseño de hardware , es que el codigo fuente  de alguna manera está disponibles a la vista. A pesar de que es un amplio y potencial término ambiguo, un común acuerdo sobre la definición está en un documento llamado  Open Source Definition (OSD), publicado por la Open Source Initiative (OSI).

 La definición no es una licencia de software libre en sí, si no algo que se utiliza para medir condiciones frente a la distribución, si se determina que cumplen con las condiciones, entonces se puede decir que es \textit{open source}. Lo que no es claro es lo que podría o debería ser hecho con una copia del código fuente.Cuando el software \textit{libre} o \textit{free} se utiliza para describir el software de código abierto, se refiere a los derechos y no al costo del usuario. La Fundación para el Software Libre (FSF) ofrece una definición para mostrar claramente qué se tiene que cumplir sobre el software para que pueda ser considerado libre (35). El termino Free Software Foundation (FOSS) es usado para referirse al software que se adhiere al OSD y FSF. El software \textit{libre} y de \textit{código abierto} es una sociedad inclusiva término que abarca tanto el software libre y software de código abierto que a pesar de describir modelos de desarrollo similares, tienen diferentes culturas y filosofías.

El software \textit{libre} se refiere a la libertad de los usuarios para ejecutar, copiar, distribuir, estudiar, cambiar y mejorar el software. El vocablo \textit{free} en ingles significa :gratis y/o libre. Por ello el término ha ocasionado confusiones dándose a entender, equivocadamente, que el software libre es gratuito o regalado. Pero no es una cuestión de presencia o ausencia de costo, puesto que el software libre no significa que no pueda ser comercial.

Stallman fundó la Free Software Foundation (FSF ) en 1985 para promover la libertad del usuario y para defender los derechos de todo el software libre( 28 ). La FSF patrocina el proyecto GNU. El software libre permite al usuario el ejercicio de cuatro libertades básicas:

\begin {itemize}
\item
 \textit{Libertad 0} Además el software \textit{libre} permite estudiar cómo funcionan y adaptarlo a las necesidades de quien lo use. Tener acceso a su código fuente posibilita, entre otras cosas, descubrir qué posibilidades tiene, etc. El adaptar el programa a las necesidades del usuario se puede suprimir partes que no le interesen, agregar otras partes que considere importantesm copiar una parte que realiza una tarea y/o adicinarla a otro programa, etc.

\item
\textit{Libertad 1} El software, sus copias y las modificaciones se pueden distribuir libremente, lo que significa poseer la libertad de redistribuir el programa, gratis o con algún costo, ya sea por mail, FTP, o en CD, redistibuyéndolo a una persona o a varias, a una persona que vive en otro país, etc.

\item 
\textit{Libertad 2} Es posible mejorarlo y hacer pública esas mejoras. La libretad de hacer un programa mejor, implica que se puede hacer menores los requerimientos de hardware para funcionar, que tenga mayores prestaciones, que sus requerimientos no sean tan altos, que tenga menos errores, etc. El poder liberar las mejoras al público quiere decir que si se realiza una mejora que permita un requerimiento menor de hardware, o que haga que ocupe menos espacio, se puede redistribuir ese programa mejorando o simplenete propoenr la mejora en lugar público (un foro de noticias, una lista de correo, un sitio web, un FTP, un canal de chat).

\item 
\textit{Libertad 3} El usuario al poseer el código fuente tiene poder de decisón, ya que podrá elegir quién puede modifica los programas que ha adquirido para mejorarlos (o bien mejorarlos el mismo). Es decir esto permite que no exista un monopolio, porque en el caso de que un software sea discontinuado el usuario podrá nuevamente (al poseer el código) elegir a un desarrollador para continuar utilizando el software que fue discontinuado. Además el usuario no estará completamente a merced de tener que renovar su hardware y software constantemente según ocurre a menudo con las políticas de las empresas que producen software privativo y también será libre de vender o redistribuir software libre.
 
 \end {itemize}
 
Mediante la licencias un autor permite el uso de su creación a otras personas, de la manera que el cree aceptable. En ese sentido la licencia es el intrumento que regula las maneras en que el usuario puede utilizar el software.

También una licencia de software es un contrato que determina en qué condiciones el usuario puede utilizar el programa informático y qué obligaciones asquiere para su uso. Cuando se instala un programa informático, o a veces, incluso, por el simple hecho de abrir el sobre que lo contiene, se esta aceptando las condiciones de su licencia de software.

Cuando IBM comenzó la venta de computadoras a gran escala en la década de 1960, el software venia incluido como código fuente. Una década más tarde, sin embargo, comenzaron a "desagregar"  el software, y se convirtió en habitual para los fabricantes de computadoras, no solo limito  el uso del mismo código fuente a los competidores, sino que también elimino la capacidad de modificar el código libremente y compartirlo%\cita{}(26).  

La licencia División de Software de Berkeley (BSD) y la Pública General del proyecto GNU (GNU GPL) son dos de las primeras licencias de código abierto. Ambos proporcionan la libertad de usar software de código fuente abierto para cualquier propósito y permitir la modificación y la distribución de su código fuente sin tener que pagar regalías. Las diferencias entre los dos pone de relieve una diferencia ideológica entre los defensores del código abierto .

Un punto significativo de diferencia entre las licencias BSD y GPL es que este último le permite
\textit{modificar su copia o copias del Programa o cualquier parte de el, y copie
y distribuir tales modificaciones ... supuesto que además ... hace que la
totalidad de cualquier trabajo que distribuya o publique y que en todo o en
parte contenga el Programa o cualquier parte del mismo, ya sea con o sin
modificaciones, para ser autorizadas sin cargo alguno para terceras partes bajo el
términos de esta Licencia Pública General.(GPLv1) ( 29 ). } %\cita{}

La GNU GPL se conoce como una licencia \textit{viral}, en que cualquier diseño haciendo uso de código ya licenciado bajo la GNU GPL debe ser entonces licenciado bajo la
GNU GPL o cualquier licencia juzgados como igualmente sin restricciones por la FSF. En pocas palabras, una condición de uso del código licenciado bajo GPL es que su diseño se debe tener licencia bajo la GPL o una licencia compatible. Las licencias que se consideran compatibles con la GPL por la FSF son generalmente similares en las libertades que garantiza el software libres. La licencia se transmite al código que hacen uso de ella. El GNU GPLv3 exige que cuando un proyecto adopta esta licencia el código fuente debe estar disponible y que las patentes o derechos digitales (DRM) no inhiben a otros del uso del diseño. 

La licencia BSD modificada es básicamente la misma que la original sin la clausula de publicidad. De acuerdo con dicha cláusula, todo el material de publicidad en el cual se menciona características o la utilización de este software tenia que mostrar el siguiente asentimiento:"este producto incluye software desarrollado por la Universidad de California, Berkeley y sus contribuyentes ".

Esta cláusula de publicidad no permitía que fuera compatible con la lincencia GPL pero a partir de su versión 2.0 fue eliminada y la licencia pasó a ser compatible con la GPL.

La GNU GPL es en cierto modo, más restrictiva que la licencia BSD sobre las libertad de hacer lo que uno quiere con el código fuente. En la GNU se estipula que el código modificado debe estar disponible, y cualquier diseño utilizado con código GPL tiene también que venir bajo la GNU GPL. Sin embargo, esto no es diferente a cualquier licencia comercial, donde el código fuente escrito por un empleado de una empresa,o todo el código que se modifican o crean esta bajo la licencia exclusiva de la empresa. En el caso de la licencia de GNU, sin embargo, los usuarios están obligados a mantener su diseño abierto y libre como la GPL de GNU hace, de la misma manera el empleado de la empresa está obligado a mantener su código propietario en secreto para cualquiera que no sea de la  empresa.

Otro punto de controversia es el uso combinado de los diseños en los que cada uno esta bajo una licencia diferente, dando lugar al concepto de \textit{compatibilidad de la licencia}. En el caso de que un diseño utilizara una librería bajo licencia GPL, la GNU GPL especifica que se puede utilizar si el diseño  que requiere la librería este también bajo la GPL. 

 Una solución para aquellos que deseen escribir bibliotecas, y no tienen la
interpretación más estricta de la trabajos derivados se les aplica la propuesta de el  Proyecto GNU la Licencia Pública General Reducida de GNU, o más conocida por su nombre en inglés GNU Lesser General Public License (antes GNU Library General Public License o Licencia Pública General para Bibliotecas de GNU),o simplemente por su acrónimo del inglés GNU LGPL, esta licencia permisiva se aplica a cualquier programa o trabajo que contenga una nota puesta por el propietario de los derechos del trabajo estableciendo que su trabajo puede ser distribuido bajo los términos de esta "LGPL Lesser General Public License". El "Programa", utilizado en lo subsecuente, se refiere a cualquier programa o trabajo original, y el "trabajo basado en el Programa" significa ya sea el programa o cualquier trabajo derivado del mismo bajo la ley de derechos de autor: es decir, un trabajo que contenga el Programa o alguna porción de él, ya sea íntegra o con modificaciones o traducciones a otros idiomas.
Otras actividades que no sean copia, distribución o modificación no están cubiertas en esta licencia y están fuera de su alcance. El acto de ejecutar el programa no está restringido, y la salida de información del programa está cubierta sólo si su contenido constituye un trabajo basado en el Programa (es independiente de si fue resultado de ejecutar el programa). Si esto es cierto o no depende de la función del programa.%\cita{wiki}

Estas diferencias de opinión con respecto a lo que constituye una obra derivada, y
la ambigüedad en torno a otros aspectos de la concesión de licencias de código abierto podría tener consecuencias para campos como el diseño de hardware y se discutirá en una sección posterior.

La principal diferencia de opinión, sin embargo , se deriva del hecho de que la libre
Software Foundation desean hacer imposible que el software propietario  pueda utilizar
software liberado bajo la GNU GPL. La FSF argumenta  que los que no están dispuesto a permitir que otras personas vean o modificar libremente su código aprovechen de los que si lo permiten. Otras licencias de código abierto, sin embargo ,son más permisivas en la utilización de sus diseños como por ejemplo en el codigo fuente de las librerias, en aplicaciones propietarias.

El objetivo del Proyecto GNU de implementar un sistema operativo completamente libre y gratuito, avanzo a buen ritmo en la década del 90, pero le faltaba la lleve de componentes del nivel más bajo.

El núcleo Linux iniciado por Linus Torvalds, fue liberado para poder ser modificado libremente en 1991. La licencia inicial, no fue exactamente una licencia d software libre, sin embargo la version 0.12 lanzada en febrero de 1992, fue licenciada nuevamente por Torvalds bajo los términos de la licencia pública general de GNU. Así como Unix en su tiempo, el núcleo de Torvalds atrajo la atención de programadores voluntario.

Hasta este punto, la falta de núcleo del proyecto GNU significaba la no existencia de un sistema operativo libre completo. El desarrollo de núcleo de Linux Torvalds lleno este último hueco. La conbinación del casi terminado sistema operativo GNU y el núcleo LInux resultó en el primer sistema operativo completo de softwore libre.

Entre las distribuciones Linux, Debian GNU/Linux, iniciada por Ian Murdock en 1993, es notorio por estar comprometido explicitamente con los prinicipios de GNU y la FSF del softwore libre. Los principios de desarrolladores de Debian estan expresados en el contrato social de Debian. Desde sus inicios, el proyecto de Debian ha estado intimamente ligado con la FSF, y de hecho fue patrocinado por la FSF durante un año. Sin embargo Debian ya no se considera software libre por la FSF y el proyecto GNU ya que el núcleo Linux incluido con Debian contiene partes privativas ademas de ofrecer repositorios con software no libre (18).

El GNU/Linux (o simplemente Linux) continúa siendo software libre desarrollado por programadores voluntarios, pero también muchas compañías ofrecen productos personalizados basados en el núcleo Linux así como distribuciones con soporte comercial.

El nombre del sistema operativo continúa generando controversias dentro de la comunidad de software libre, por un lado el proyecto GNU y otros grupos de usuarios piden que el sistema sea llamado GNU/Linux argumentando que la mayoría de los sistemas basados en el nucleo del Linux son derivaciones del sistema operativo GNU, que empezaron a desarrollarlos 7 años antes que el Linux Torvalds publicara su núcleo (19). Por otro lado, los grupos que apoyan el nombre Linux para referirse al sistema operativo completo y no solo a su núcleo, argumentan que el nombre Linux es mas reconocido, mejor recibido y mas practico (20). Es importante señalar que las mayorias de versiones de sistemas operativos basados en Linux, contienen muchas otras partes además que las desarrolladas por el proyecto GNU y el núcleo Linux, el ejemplo más representativo de estos componentes ajenos a GNU.

Ejemplos de otros exitosos y ampliamente adoptado proyectos de código abierto son el servidor web Apache , la oficina de los servicios públicos paquete OpenOffice.org y el proyecto Mozilla, que crea software de correo electrónico y navegador web. A pesar de que esta última pareja no eran originalmente de código abierto, el lanzamiento de su código fuente bajo licencias de código abierto fue significativa, y continúan los proyectos populares de la actualidad.

Tras la adopción creciente de software de código abierto en la década del 90, una organización llamada la \textit{Open Source Initiative} (OSI) fue iniciado por algunos los desarrolladores de software que se propusieron convencer a la gente que el software libre (como lo fue comúnmente conocida en ese entonces) tenía un lugar en la industria comercial. El éxito del modelo sorprendió a mucha personas, y demostró que era un modelo de desarrollo viable.  

A medida que la popularidad y la utilidad de Internet fue creciendo, también lo hicieron las  comunidades de codigo abierto por diferentes causas. La atracción y la comunicación que produce internet en personas interesadas en el desarrollo de código abierto proporcionan la chispa para las grandes comunidades de código abierto. Lo que ha dado como resultado un sinnúmero de comunidades y  grupos que contribuyen a el desarrollo de código fuente abierto de casi cualquier cosa.

Un sitio web, con sus comienzos en el año 2000, llamado OpenCores que proporcionar un sitio para la comunidad de hardware de código abierto. Fue una de las primeras comunidades de desarrollo de hardware y actualmente la mas grande, con más de cien mil usuarios y cerca de mil proyectos. Donde su principal objetivo es diseñar y publicar diseños de núcleo bajo una licencia de hardware siguiendo el modelo de la Licencia LGPL para el software. Estan comprometidos con el ideal de libre disposición, de libre uso y hardware de código abierto reutilizable.%\cita{}www.opencore


		
		\subsection{\textcolor{orange}{Motivación para la adopción del OpenSource}}

Dentro del software de código abierto se tiene alternativas como software multimedia avanzada, de productividad de oficina,  herramientas de gráficos, sistemas operativos y software de comunicaciones, por lo general libres para descargar y utilizar. Los gobiernos y las grandes empresas están aprovechando cada vez más el software de código abierto que existe y se están convirtiendo en importantes contribuyentes a los proyectos del software que adoptan. Las tendencias recientes han hecho mucho para disipar la imagen de la legión de solitarios desarrolladores de código abierto que son los únicos contribuyentes de trabajo. 
Como las entidades comerciales están aumentan la adopción y utilización de los proyectos de software libre,  se están convirtiendo en los contribuyentes más frecuentes. El kernel de Linux tiene ahora la mayor parte de sus contribuciones de código de las entidades comerciales, ya sea por que están trabajando con el núcleo Linux en sus productos, o que deseen asegurar el apoyo a su hardware en el kernel, tales como Intel ,AMD e IBM. Lo mismo es cierto para proyectos como Apache y MySQL.

La gran cantidad de software de código abierto disponible que existe ofrece la elección entre la adopción de \textit{software libre y de código abierto}. 

La colección de herramientas de progrmación binutils y el compilador GCC creados por el proyecto GNU estan siendo desarrollados y mantenidos en gran parte por entidades comerciales interesadas en mantener sus plataformas en las mejores condiciones. El proyecto GNU impulsa el desarrollo de las herramientas GCC usando un entorno de desarrollo abierto y soportado por muchas plataformas con el fin de fomentar el uso de un compilador-optimizador de clase global, que pueda atraer a muchos equipos de desarrollo, y asegure que GCC y los sistemas GNU funcionen en diferentes arquitecturas y diferentes entornos, y más aún, para extender y mejorar las características de GCC. 

El aumento del potencial comercial del software de código abierto trae como consecuencia que las empresas aporten recursos a estos proyectos en lugar del desarrollo y mantenimiento de su propio conjunto de compiladores y herramientas de su propiedad como como por ejemplo en el caso del GCC. Este es uno de los objetivos de los creadores de código abierto - para proporcionar una buena base de software con código abierto donde los desarrolladores se encuentren cómodos para adoptar  \textit{software libre y de código abierto}, y como consecuencia la publicación del código fuente de los trabajos derivados
produciendo el aumento del software existente evitando la tarea de empezar a desarrollar desde cero o comprar una solución propietaria. 

 Estas son algunas de las motivaciones para la adopción y contribución de código abierto podrían ser muchas más y variadas eso dependerá de la funcionalidad del proyecto de codigo fuente. A pesar de su éxito en el software en el diseño de hardware de código abierto  no tuvo el mismo éxitos los motivos se estudiar más adelante.

		\subsection{\textcolor{orange}{Desventajas de la adopción del OpenSource}}

A pesar del gran aumento en popularidad y uso del software de código abierto, han sido muchos los detractores del desarrollo de código abierto en la actualidad. 
El codigo que no es opensource puede ser desplazado del mercado por alguna alternativa que si lo sea sin embargo, comúnmente estas alternativas no son tan buenas, al ser opensource no ofrecen demasiadas cosas para innovar lo suficiente.

Despite open source software’s seemingly unstoppable rise in popularity and
use, there have been many detractors of open source development to voice their
opinion in recent times. Obviously there’s going to be opponents of open source
who’s established dominance of a niche market may be threatened by an open source
alternative, and may suffer diminishing revenues because of it, but these opponents
rarely argue interesting or useful points of the debate and suffer mainly from failing
to innovate sufficiently, a point which will be discussed further.
There are arguments that open source development impedes competition by reducing
the chances a proprietary developer has of developing a similar, potentially
better, solution because the open source variant usually gets used regardless of its
failings largely because it is initially free of cost to the user. Thus, it is argued, that
innovation is stifled because smaller companies can’t get a foot in between the open
source solution and the products of larger established firms whereas, previously, they
might have had an opportunity to prove their technology. The counterpoint to this
is that any sufficiently superior proprietary implementation will of course attract
users, and all that is occurring is a raising of the required quality-of-implementation
bar due to the presence of a free-of-cost alternative. One suggestion here would be
that these innovators leverage the existing open source implementation to demonstrate
their innovation, and thus improve the open source implementation, hopefully
allowing it to compete with any dominant proprietary player. In doing so the developers
become knowledgeable about the project they’ve contributed to, become
known among the users of the software, and develop a business providing development
or support services for the project they’ve improved. The obvious down side
to this is that they have exposed their innovative technique, and cannot reap the
rewards as done traditionally in proprietary software products. However, this is
offset by their reduced overhead in developing their product (large proportions of
the supporting infrastructure adopted from open source implementation), and their
improved potential as a gun-for-hire on the newly improved open source project
which, in turn, attracts other contributors who decide to work with the project.
Other standard complaints about open source projects are in regard to the quality
of implementation. It is true that open source implementations do vary greatly
in quality and functionality and this is typically due to a limited contributor base
that is implementing only enough so that it works for their application. For the
uninitiated, the barriers to entry for contributing to an open source project can
be significant and this is another common criticism of open source development.
Larger, better managed projects, typically do not have these issues as they adopt a
more professional approach to the development, and typically have full time maintainers
who will ensure any new features do not cause errors elsewhere, or regress
the project’s functionality. However, on smaller projects, with only a handful of
contributors, unfinished features can be common. On the other hand as the design
is completely open, and although there’s a relatively steep learning curve, missing
features can be added and problems can be fixed by anyone, as they’re required.
There’s no doubting some very useful software has been written and contributed
to open source software projects, however open source should not be seen as an innovative
force, rather a step on the way to further commoditising a technology.
Entrepreneurship and the profit motive typically drive the high risk and high innovation
firms which are involved in cutting edge technology implementation. The
whole premise of the GNU Project (GNU is a recursive acronym for “GNU is Not
UNIX”) was to develop, in essence, a free, open source copy of UNIX applications
and operating system. This was not innovation, rather imitation but with a different
goal for the resulting work. The Linux kernel was begun for similar reasons.
It demonstrated engineering capability but not ingenuity, at least not at that time.
It is not true to say that what has been developed in and around those projects
doesn’t have its innovative elements. It is one thing to wish to re-implement an
existing application for largely academic purposes, and another to wish to invest
large amounts of time and money to develop a new concept wishing to see a return
based on the innovation, rather than the accessibility, of the design.

		\subsection{\textcolor{orange}{Mas motivación para la adopción para el desarrollo OpenSource}}

Una de las motivaciones para el desarrollo de código abierto desde el punto de vista comercial,  proviene de la capacidad de proporcionar y cobrar por algún tipo de servicio extra del proyecto de código abierto.A pesar que el IP este disponible públicamente, implementar o personalizar el proyecto normalmente requiere experiencia en el correspondiente disciplina y con el proyecto en particular. Las empresas que adoptan y mantien una solución de código abierto por lo general tienen sólo el costo de los conocimientos necesarios para hacerlo, sin tener que pagar regalías o licencias adicionales.  

En la actualidad hay alternativas de código abierto a los sistemas de software propietarios de IT (Tecnología de la información),  los desarrolladores de código abierto renuncian a ciertos derechos sobre la IP, la que gran parte no era su propia idea o considera innovadora, para comenzar a ganar de otra forma como por ejemplo realizando servicios de mantenimiento o adaptación de acuerdo a las requerimientos necesarios en el proyecto derivado.

A pesar de que el software de código fuente abierto no es tradicionalmente un generador continuo de productos innovación no se opone a que sea la estrategia de desarrollo elegida para una tecnología innovadora. Cualquier diseño innovador opensource suele tener retornos valiosos para la inversión necesaria para llevarla a cabo. Sin embargo, con alternativas de código abierto que brotan de forma relativamente rápida, su ventaja no puede durar por mucho tiempo producto de que otros toman nota de lo que han hecho desarrollos innovadores y si vale la pena el producto, utilizan la soluciones de código abierto. Esto  Puede llegar a ser una opción interesante para los desarrolladores que emplean el desarrollo de código abierto para empezar con una base lo que trea como consecuencia el ahorro de tiempo para el desarrolladar del producto derivado, con la ventaja  de poder competir frente a  implementaciones propietarias, con la capacitad de proporcionar soporte técnico a largo plazo para una aplicación. Esto es un buen método, donde inicialmente el producto está autorizado por una parte y al liberar  el código fuente permite a otros desarrolladores mejorar el proyecto.

Como el ciclo de vida de un producto llega a su fin , puede ser ventajoso para software privativos liberar el código fuente para permitir a cualquier usuario con el conocimiento que requiere poder darle soluciones los problemas derivados de las actualizaciones inevitable de las plataformas que se producen . 

Todavía hay un problema aquí, sin embargo, como la implementación propietaria
mantiene su dominio, mientras que no se aparezcan una fuente de código abierto equivalente, el diseñador por lo general no elige liberar el código tomando entonces el riesgo de que aparezca un aplicación diferente con funciones equivalentes y gane más popularidad,  y por lo tanto la idea del diseñador original sigue, pero no su capacidad para proporcionar apoyo a la misma.

Esta breve mirada a la situación actual de código abierto ha indicado que el código abierto
se ha convertido en una fuerza a tener en cuenta en el mundo del software, pero este no es el caso en la actualidad para el desarrollo de hardware de código abierto.
 A medida que la cantidad de código abierto disponible aumenta, y la comprensión de los márgenes de aproximación , lo hará
seguramente continuará para demostrar que es un enfoque valioso para el desarrollo de
la tecnología .

As the wealth of available open source designs increases, and the understanding of the approach spreads, it will surely continue to prove itself as a worthwhile approach to the development of technology.
%%%%%%%%%mal%%%
Uno de los argumentos en contra del desarrollo de código abierto es por lo general que es usadas por el usuario por ser inicialmente libres de costo por lo general tienen que tener conocimientos técnico. En le caso de las empresas que utilizan el software de codigo fuente abierto en muchos casos tienen la necesidad de dedicar recursos a la reparación de errores y a la capacitación del personal ya que tiene una curva de aprendizaje mayor que software privativos.

Otro contratiempo del opensource es que no existen compañías únicas que respalden toda la tecnologia

ta en la innovación que es sofocada por las empresas más pequeñas no pueden poner un pie en una solucion de código abierta y los productos de grandes empresas consolidadas , mientras que , previamente , se podría haber tenido la oportunidad de probar su tecnología. 

 Una sugerencia aquí sería que estos innovadores aprovechan la implementación de código abierto existentes para demostrar su innovación, y mejorar así la implementación de código abierto , es de esperar lo que le permite competir con cualquier reproductor propia dominante. De este modo los desarrolladores adquirir conocimientos sobre el proyecto que han contribuido a , se convierten en conocido entre los usuarios del software, y desarrollar un negocio que proporciona el desarrollo o servicios de apoyo para el proyecto han mejorado . La desventaja obvia a esto es que se han puesto de manifiesto su técnica innovadora , y no puede obtener la recompensas como se acostumbra en los productos de software propietario . Sin embargo , esto es compensado por la reducción de gastos en el desarrollo de su producto ( una gran proporción de la infraestructura de apoyo adoptadas en aplicación de código abierto ), y su
mejora potencial como arma a sueldo en el proyecto de código abierto nuevo y mejorado
que , a su vez , atrae a otros contribuyentes que decidan trabajar con el proyecto .

Curva de aprendizaje mayor. (Cada día menor)
No posee garantía proveniente del autor.
Se necesita dedicar recursos a la reparación de errores.
No existen compañías únicas que respalden toda la tecnología.
La mayoría de la configuración de hardware no es intuitiva.
Únicamente los proyectos grandes y de trayectoria tiene buen soporte, tanto de los desarrolladores como de los usuarios.
En ocasiones el usuario debe tener conocimientos de programación.
La diversidad de distribuciones, métodos de empaquetamiento, licencias de uso, herramientas con el mismo fin, etc., pueden crear confusión en cierto numero de personas.

%Conclusión!!Trabajar con un sistema final bajo licencias de hardware siguiendo el modelo de la Licencia LGPL para el software. Estamos comprometidos con el ideal de libre disposición, de libre uso y hardware de código abierto reutilizable.



	%	\subsection{\textcolor{orange}{Deferencias}}%http://www.slideshare.net/wilberth1594/tesis-alex-8795926,julius
%Aca vamos a poner las libertades que permiten uno y otro
%		\subsection{\textcolor{orange}{GPL}}
	%	\subsection{\textcolor{orange}{LGPL}}
%Revisemos este título -- PABLO JULIUS :P
	%	\subsection{\textcolor{orange}{OpenSource}}
		

		\subsection{\textcolor{orange}{ OpenSource}}

La apertura del código de la propiedad intelectual desarrollada para el proyecto OpenRISC, y otros en OpenCores, ha sido a la vez un obstáculo y una ayuda, ya que pone al desnudo el estado del desarrollo, pero es útil, ya que permite que cualquiera pueda participar en el continuo desarrollo de núcleos. Esta subsección discutirá los pros y los contras de la fuente abierta enfoque.

		\subsubsection{\textcolor{orange}{No verificado y No populares}} 

A pesar del uso y la aceptación del software desarrollado bajo licencia de código abierto, los proyectos RTL de código abierto no han recibido el mismo tipo de interés o la participación de las empresas más grandes de IP. 

Un problema es para las personas que desarrollan IP destinados para su implementación en ASIC, es la falta de un conjunto de herramientas de verificación para los IP de codigo abierto, y por lo tanto la incapacidad para verificar rápidamente la funcionalidad de un core, esto es inaceptable dado el elevado costo de la corrección de errores. Se podria sugerir la inclusión obligatoria de una herramienta de verificacióne con el core, sin embargo, las herramientas estándares de verificación que se encuentran disponibles en la industria son de entidades propietarias y tienen un elevado costo y pueden variar de un proveedor a otro. 

Es sorprendente que no existen herramientas de verificación de código abierto en la industria todavía, esto pone un serio obstáculo para la entrada al mercado de desarrolladores IP por el importante costo del conjunto de herramientas de Entorno de desarrllo integrado (EDA) capaces de realizar la verificación.A falta de las opciones de EDA de código abierto continuarán limitando las aplicaciones de estos núcleos opensource, y para minimizar el riesgo las implementaciones se realizaran en dispositivos como las FPGAs donde generalmente se pueden hacer cambios  del RTL con un bajo costo 
 

\subsubsection{¿Cual es su objetivo? }


Una barrera para el desarrollo de hardware de código abierto que no la tiene el desarrollo de software, es el requerimiento de la plataforma donde implementar el diseño del prototipo,así como herramientas  de progrmacion y depuración gratuitas . Estas plataformas, típicamente placas que contienen múltiples periféricos ICs basadas en una FPGA, así como la depuración de hardware y programación no son independientes de un proveedor. A esto se suman la complejidad de las herramientas de programación de los proveedores para la FPGA, así como el desarrollo de hardware con una curva de aprendizaje relativamente empinada que perjudica a los principiantes.
También  la utilidad de cualquier diseño de hardware que se podría implementar en una FPGA está limitada por el hecho de que se realiza a un nivel muy bajo de abstracción, y para lograr un resultado positivo "útil" para los experimentador o aficionado, por lo general requiere un gran trabajo a través de muchos niveles de abstracción para lograr algo que sea fácilmente utilizable a partir de una interfaz de una PC. 

Un ejemplo podría ser el desarrollo de un core para que realice transacciones de I/O de un sensor, para proporcionar información a una aplicación por ejemplo que controle la temperatura en un espacio determinado. Esto requeriría el desarrollo y prueba del modelo de hardware y la implementación en FPGA . Asumiendo que es un microprocesador el que se encuentra corriendo sobre la FPGA, dando servicios de red a través de un sistema operativo de tiempo real (RTOS), este módulo personalizado debería requerir el desarrollo de una capa de software, lo que significa la necesidad de un driver para que permita al sistema operativo en tiempo real interaccionar con el periférico, haciendo una abstracción del hardware y proporcionando una interfaz para usarlo. El sistema operativo en tiempo real se conecta con la aplicación que se ejecuta en el microprocesador de la FPGA para proporcionan lo datos a través del enlace de red, solo entonces los datos de este sensor se encontraran disponibles para la aplicación de nivel superior. This is just one example where, quite probably the designer might have chosen a solution that uses a standard bus, however there’s often cases for custom controller or interface cores in FPGAs to provide
access to legacy, or very-new or esoteric bus standards, and highlights the extra work required beyond writing RTL to provide the physical interface.
Viendo la cantidad de desarrollo y pruebas requeridas para poner en práctica estas soluciones, es fácil sentirse abrumado por la cantidad de trabajo necesario para completar una tarea tan aparentemente trivial.

Comparando esto con adoptar una programa opensource, que consiste en la descargar de una código fuente, compilarlo y ejecutalo en su computadora. Donde La aplicación puede ser ejecutada en el  host para comprobar la funcionalidad y la mayor parde del ciclo de desarrollo termina allí. Las diferencias son el acceso inherentes a la plataforma de desarrollo (el host), las herramientas de desarrollo mucho mas simples (gcc, make en el sistema host) el ciclo de desarrollo, pruebas más cortas y más fácil (que se ejecuta en el equipo host a través de un shell.)

A medida que mas proyectos opnesource son desarrollados y los sistemas de desarrollo sean mas ágiles, se puede esperar que estas barreras para los desarrolladores de diseño de hardware opensource puedan ser superadas. En los principios del del desarrollo de software opensource parecían igual de complicados. Se espera que con el tiempo y el aumento de participantes el hardware de código abierto alcance el mismo exito.En ese momento, los diseños serán tan grandes que no cabrán en los dispositivos programables actuales. La reconfigurabilidad será un elemento imprescindible. Las fronteras entre el hardware y el software se harán cada vez más difusas. El deseo, casi utópico, es lograr correr un kernel Linux hardware basándose en las posibilidades que nos ofrece la reconfigurabilidad. 
	

		\subsection{\textcolor{orange}{Licencias}}

Una cuestión que queda por resolver es el de la concesión de licencias para el diseño de hardware de código abierto. El proyecto OpenRISC utiliza licencias públicas del proyecto GNU. Estos refieren específicamente a software, y no se sabe lo bien que se aplican a hardware.
El sitio web del proyecto GNU contiene una sección con preguntas frecuentes (FAQ) que se ocupa de esta consulta. Afirma lo siguiente.

\textit{Cualquier material que puede ser licenciado con derechos de autor puede ser licenciado bajo la GPL.
GPLv3 también se puede utilizar para materiales de licencia cubiertos por otras leyes copyrightlike, como máscaras de semiconductores. Así, por ejemplo, puede liberar un dibujo de un diseño de hardware bajo la GPL. Sin embargo, si
alguien utilizó esa información para crear hardware físico, que lo harían
no tienen obligaciones de la licencia al distribuir o vender el dispositivo: se
queda fuera del ámbito del derecho de autor y por lo tanto la propia GPL.}

Esto no es claro para los diseños específicos para FPGA o código, incluso RTL, ya que puede terminar como un conjunto de máscaras, o puede terminar como un flujo de bits binario para configuración de una FPGA.
Una indicación de la naciente idea de desarrollo de hardware de código abierto proviene de la publicación reciente (febrero de 2011) de un conjunto de principios para los participantes de la comunidad de hardware de código abierto. El siguiente es el código abierto Hardware (OSHW) Declaración de Principios 1.0 de FreedomDefined.org.

\textit{El Hardware de código abierto cuyo diseño está a disposición del público
por lo que cualquier persona puede estudiar, modificar, distribuir, poner, y vender el
diseño o hardware basado en ese diseño. La fuente de hardware, el diseño
del que está hecho, está disponible en el formato preferido para realizar
modificaciones a el mismo. Idealmente, el hardware de código abierto utiliza fácilmente los componetes y materiales disponible, procesos estándares, una infraestructura abierta, sin restricciones
contenida, herramientas de diseño y de código abierto para maximizar la capacidad
de las personas para hacer y usar el hardware} %\cita{}(65)

Estas publicaciones proporcionan un punto de referencia para saber si el diseño puede estar bajo licencia "open source hardware".
El FreedomDefined.org es una lista con principios que específicade  fuente y  documentación, trabajos derivados y las limitaciones de la licencias. Se espera de acuerdo con estos principios, que todo el material este disponible como código fuente y la documentación para el diseño. Cualquier trabajos derivados o modificado deba estar disponible. 
Cualquier licencia de hardware de código abierto se puede utilizar para restringir (o en este caso, de forma deliberada sin restringir)los planes de un diseño, pero no el uso del dispositivo fabricado. Estos son conceptos que se encuentran a menudo en las licencias de software de código abierto, pero de nuevo, no es tan claro como se aplica en el casos del diseño del hardware de código abierto como es para el software. 

Por ahora, la primera licencia de hardware de código abierto es la  Amateur Packet Radio Licencia Open Hardware Tucson ( TAPR OHL). Los autores OHL TAPR identifican el problema con las licencias de software existentes, si bien los derechos de autor protegen la documentación de copias, modificaciones y distribuciones, que tiene poco que ver con el derecho de hacer , distribuir o usar un producto basado en la documentación %\cita{} ( 66 ) .
Su licencia identifica patentes como un problema, pero afirma que quienes se beneficien de la OHL no podran
presentar una demanda alegando que el diseño infringen sus patentes u otra propiedad intelectual.
How open source hardware licenses and patent law will be compatible with regards to handling infringement is yet to be seen
En consecuencia, la TAPR OHL ha sido adoptada por un puñado de aficionados y para los intereses de empresas comerciales. Ha recibido críticas
del Instituto de Código Abierto (OSI) en la adopción de un significado diferente de la  palabra " distribución " que se suele utilizar en sus licencias, y por lo tanto no tiene un amplio apoyo entre los promovedores de código abierto%\cita{} (67) . 
Sin embargo, es posibles que licencias alternativas de hardware de código abierto surjan para adaptarse a necesidades.
Para el proyecto OpenRISC hay un equilibrio para afrontar la adopción entre una licencia que es demasiado liberal, y por lo tanto menos probable que resulte en la contribución a la comunidad de desarrollo, y una licencia que fomenta mas el desarrollo de código abierto, pero se considera entonces demasiado restrictiva con respecto a la utilización de codigo abierto IP con una IP patentada.

Por un lado, hay un deseo de aumentar la participación en el desarrollo de hardware de código abierto en general, y específicamente en el proyecto OpenRISC MinSoc y OrpSoc,para aumentar el conjunto de trabajos disponibles, esto se puede lograr utilizando un licencia viral como lo es la GNU GPL (considerando la síntesis del codigo RTL como un proceso de compilación estatica). 

Por otra parte el trabajo de desarrollo de diseños ASIC privativos de gran escala ayuda a demostrar valor de los IP, por lo que una licencia que permita el uso de IPs Open Source en conjunto con  IPs privativos es deseable.
Para la implementación RTL del OpenRISC, el OR1200, la no-viral menor GNU Lesser (L) licencia GPL se ha utilizado y, a pesar de la creación de instancias de un bloque de IP RTL
en un diseño de "hardware" no se trata de forma específica en el (L) GPL, es la última
(más liberal) criterio de la licencia que se ha tomado para el proyecto OpenRISC
hasta el momento.
 

What remains, however, is for actual licenses to be written, applied to works
and their validity tested. For now, the first major open source hardware license to
be released is the Tuscon Amateur Packet Radio Open Hardware License (TAPR
OHL.) The TAPR OHL authors identified the problem with existing software licenses
as being that while copyright protects documentation from unauthorized
copying, modification, and distribution, it has little to do with your right to make,
distribute, or use a product based on that documentation(66). Their license identifies
patents as an issue, but claims those who benefit from the OHL cannot then
bring a lawsuit claiming that the design then infringes their patents or other IP.
How open source hardware licenses and patent law will be compatible with regards
to handling infringement is yet to be seen. Regardless, the TAPR OHL has been
adopted by a handful of hobbyist and commercial interests. It has received criticism
from the Open Source Institute (OSI) for adopting a different meaning of the
word “distribution” than is typically used in their licenses, and thus does not have
widespread support among established open source promoters(67). However, it is
likely alternate open source hardware licenses will emerge to suit most needs.
For the OpenRISC project there is a balance to strike between adopting a license
that is either too liberal, and thus less likely to result in contribution back to
the development community, and a license that encourages more open source development
but is then deemed too restrictive with regard to the use of open source
IP with proprietary IP. On the one hand, there is a desire to increase the participation
in open source hardware development in general, and in the OpenRISC
project specifically, and to increase the body of available work, which a viral license
along the lines of the GNU GPL (where synthesis is considered equivalent to static
linking) can achieve. On the other hand the use of the work in largely-proprietary
designs by ASIC houses is desirable as it helps prove the IP’s worth, and so a license
permitting the use of open source IP along side proprietary IP is desirable.
For the OpenRISC’s RTL implementation, the OR1200, the non-viral GNU Lesser
(L)GPL license has been used and, although the instantiation of an RTL IP block
in a “hardware” design is not dealt with specifically in the (L)GPL, it is the latter
(more liberal) licensing approach that has been taken for the OpenRISC project
thus far.
However, perhaps this factor has, too, contributed to the relatively low level
of community participation thus far in the OpenRISC project. Comparatively,
the early stages of the open source software movement saw a lot of code released
under the GPL, which ensured all other code used with it came under a similarly
“restrictive”, viral license, and ensured a large body of code was released into the
public domain. However, not all open source software was released under these viral
licenses, with the BSD and MIT licenses being less restrictive with enforcing the
freedom of the user.

		\subsection{OpenRisc}

Como se dijo anteriormente en el debate sobre la tecnología de código abierto por lo general los modelos de desarrollo de código abierto no son imnovadores.
 La mayor parte de los proyectos de software libre tienen como objetivo utilizar recursos ya existentes y bien conocidos de manera que permitan la apertura y eliminación de restricciones que se encuentran en otra implementaciones propietarias. Esta es la duda en el caso de la OpenRISC proyecto. Es en gran medida tomando ideas que ya son bien conocidos y comoditizados
y la creación de una versión con más libertad para el usuario final. Había muy poco, si
nada, innovador en la especificación arquitectónica OR1K. Esto no quiere decir
los resultados no tienen ningún valor. Tampoco necesariamente excluye cualquier OpenRISC futuro
o implementaciones de arquitecturas con el objetivo de innovar.

		\subsection{\textcolor{orange}{conclución}}

A día de hoy los diseños hardware de código abierto son una realidad palpable. Cualquiera puede descargarlos de la red y utilizarlos en sus diseños. Los componentes típicos de un sistema tales como un controlador USB, un microprocesador, un controlador de red, etc., tienen su alternativa en código abierto y son ya utilizados por empresas en productos comerciales, lo cual da una idea de su calidad

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CAPITULO 5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	\section{\textcolor{orange}{Microprocesadores Soft-Core}}
	\subsection{\textcolor{orange}{LEON3}}
		\subsubsection{\textcolor{orange}{Características}}
		\subsubsection{\textcolor{orange}{Benchmarking}}
	\subsection{\textcolor{orange}{OpenRISC}}
		\subsubsection{\textcolor{orange}{Características}}
		\subsubsection{\textcolor{orange}{Benchmarking}}
	\subsection{\textcolor{orange}{Nios II}}
		\subsubsection{\textcolor{orange}{Características}}
		\subsubsection{\textcolor{orange}{Benchmarking}}
	\subsection{\textcolor{orange}{MicroBlaze}}
		\subsubsection{\textcolor{orange}{Características}}
		\subsubsection{\textcolor{orange}{Benchmarking}}

\section{\textcolor{orange}{Análisis de el OpenRISC }}
		\subsection{\textcolor{orange}{Arquitectura}}
		\subsection{\textcolor{orange}{Implementación}}
			\subsubsection{\textcolor{orange}{ORPSoC}}
			\subsubsection{\textcolor{orange}{MinSoc}}
		\subsection{\textcolor{orange}{Toolchain}}
		\subsection{\textcolor{orange}{Software}}
			\subsubsection{\textcolor{orange}{Librerías}}
			\subsubsection{\textcolor{orange}{Sistema Operativo}}
			
%%%%%%%%%%%ESTUDIO DEL PROBLEMA%%%%%%%%%%%%%%%%
	
\section{\textcolor{orange}{Estudio del Problema}}
	\subsection{\textcolor{orange}{Introducción}}
	\subsection{\textcolor{orange}{Requerimientos del Usuario}}
			\subsubsection{\textcolor{orange}{En cuanto al Hardware}}
			\subsubsection{\textcolor{orange}{En cuanto al las licencias}} 
			\subsubsection{\textcolor{orange}{En cuanto Sistema Operativo}} 	 
				 		\subsection{\textcolor{orange}{Estudio de componentes y de la viabilidad para el proyecto}}	
		\subsubsection{\textcolor{orange}{Objetivo}} 	 
		\subsubsection{\textcolor{orange}{Comparación de los Soft-Core}} 
	 	\subsection{\textcolor{orange}{Conclusiones de la elección del micro Soft-Core}}
 		\subsubsection{\textcolor{orange}{Placas de Desarrollo}}
			\paragraph{\textcolor{orange}{Xilinx}}
			\paragraph{\textcolor{orange}{Digilent}} 	 
			\paragraph{\textcolor{orange}{Altera}}
 		\subsubsection{\textcolor{orange}{CONCLUSIONES DE LA ELECCIÓN DE LA PLACA DE DESARROLLO}}
 		\subsubsection{\textcolor{orange}{SELECCIÓN DE LAS HERRAMIENTAS DE DESARROLLO}} 	 
 		\subsubsection{\textcolor{orange}{Elección de Sistema Operativo}}
%\paragraph{\textcolor{orange}{}}
			
\section{\textcolor{orange}{Requerimientos y Riesgos Del Sistema}}

\section{\textcolor{orange}{Implementación}}
	\subsection{\textcolor{orange}{Introducción}}
	\subsection{\textcolor{orange}{Arquitectura}}
%Criterios para la realización de testing  (o algo asi) -- PABLO JULIUS :P
	\subsection{\textcolor{orange}{Criterio para la realización de testing}}
	\subsection{\textcolor{orange}{Entorno de ejecución}}
		\subsubsection{\textcolor{orange}{Entorno de ejecución Standalone}}
		\subsubsection{\textcolor{orange}{Entorno de ejecución linux}}
	\subsection{\textcolor{orange}{PROTOTIPO UNO: Implementación del SoC MinSoc en FPGA}}
		\subsubsection{\textcolor{orange}{Introducción}}
		\subsubsection{\textcolor{orange}{Requerimientos del prototipo}}
		\subsubsection{\textcolor{orange}{Implementación}}
			\subsubsection{\textcolor{orange}{Diagrama de Secuencia}}
			\subsubsection{\textcolor{orange}{Testing}}
		\subsection{\textcolor{orange}{Conclusión}}
	\subsection{\textcolor{orange}{PROTOTIPO DOS: Implementación del SoC OrpSoc en FPGA}}
		\subsubsection{\textcolor{orange}{Introducción}}
		\subsubsection{\textcolor{orange}{Requerimientos del prototipo}}
		\subsubsection{\textcolor{orange}{Implementación}}
			\subsubsection{\textcolor{orange}{Diagrama de Secuencia}}
			\subsubsection{\textcolor{orange}{Testing}}
		\subsection{\textcolor{orange}{Conclusión}}
	\subsection{\textcolor{orange}{PROTOTIPO TRES: Implementación del SoC OrpSoc en FPGA con Sistema Operativo eCos}}
		\subsubsection{\textcolor{orange}{Introducción}}
		\subsubsection{\textcolor{orange}{Requerimientos del prototipo}}
		\subsubsection{\textcolor{orange}{Implementación}}
			\subsubsection{\textcolor{orange}{Diagrama de Secuencia}}
			\subsubsection{\textcolor{orange}{Testing}}
		\subsection{\textcolor{orange}{Conclusión}}
	\subsection{\textcolor{orange}{PROTOTIPO tres: Implementación OrpSoc en FPGA con Linux}}
		\subsubsection{\textcolor{orange}{Introducción}}
		\subsubsection{\textcolor{orange}{Requerimientos del prototipo}}
		\subsubsection{\textcolor{orange}{Implementación}}
			\subsubsection{\textcolor{orange}{Diagrama de Secuencia}}
			\subsubsection{\textcolor{orange}{Testing}}
		\subsection{\textcolor{orange}{Conclusión}}




	


\section{\textcolor{orange}{Bibliografía}}
\subsection{\textcolor{orange}{Documentos}}
\subsection{\textcolor{orange}{sitios web}}

\end{document}