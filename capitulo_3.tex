%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CAPITULO 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Benchmarking}
	\section{Introducción}
	En informática benchmark representa la acción de ejecutar un programa de computadora, un conjunto de programas, u otras aplicaciones con el fin
	de evaluar el rendimiento relativo de un objeto, normalmente mediante la ejecución de una serie de pruebas estándar.  El Benchmarking se asocia
	generalmente con la evaluación de las características de rendimiento del hardware, por ejemplo, el rendimiento de operaciones de punto flotante de la
	CPU pero hay circunstancias en que la técnica también es aplicable al software. Los benchmarks de software son ejecutados para evaluar el
	rendimiento de compiladores o sistemas de gestión de bases de datos .
	
	Los Benchmarks proveen un método de comparación de las prestaciones de varios subsistemas que conforman la arquitectura de un sistema. Debido a que
	las arquitecturas de computadoras se han vuelto cada vez más complejas, resulta difícil comparar las prestaciones de varios sistemas de computadoras
	con simplemente evaluar sus especificaciones. Es necesario entonces la utilización de tests que permitan la comparación de diferentes arquitecturas.
	Por ej., los procesadores Pentium 4 de Intel generalmente operaban a mayor frecuencia que los Athlon XP de AMD, lo que no necesariamente debía
	interpretarse como una mayor capacidad de procesamiento.
	
	Son diseñados para imitar una clase particular de carga de trabajo en un componente del sistema. Los benchmarks sintéticos realizan esto mediante
	programas especialmente creados para dirigir la carga de trabajo en un compenente específico. Los benchmarks de aplicaciones ejecutan programas
	de uso cotidiano de los usuarios. Mientras los benchmarks de aplicaciones generalmente proporcionan una mejor medición de la performace del sistema
	respecto de aplicaciones cotidianas, los benchmarks sintéticos son más efectivos para probar compenentes individuales como discos rígidos o
	dispositivos de red.
	
	Los benchmarks tienen gran importancia en el diseño de CPUs, proveyendo a los diseñadores la habilidad de medir y realizar compartivas duranta las
	decisiones respecto a la microarquitectura. Hasta el año 2000 utilizaban el benchmark de Standard Performance Evaluation Corporation (SPEC) aunque
	las versiones SPEC para sistemas operativos Unix eran aún de gran tamaño y difíciles de usar sin modificar.
	
	Es sabido que algunos fabricantes de computadoras modificaron sus sistemas para mostrar altos indicadores de performace luego de la ejecución de los
	tests benchmark que no eran reflejados luego durante la ejecucción real de aplicaciones. Durante los 80' algunos compiladores detectaban una
	operación matematica específica utilizada en los benchmarks de punto flotante mas conocidos y reemplazaban la misma con una operacion matemática
	equivalente de ejecución más rápida. Sin embargo, esta transformación rara vez era útil en la ejecución de programas fuera del benchmark hasta que a
	mediados de los 90', cuando las arquitecturas Reduced instruction set computing (RISC) y Very long instruction word (VLIW) enfatizaron la importancia
	de los compiladores en lo relativo a la performace. Actualmente, los benchmarks son utilizados por los desarrolladores de compiladores para
	incrementar no solo sus indicadores de benchmark sino también su performance en aplicaciones reales. Las CPUs que poseen mas unidades de ejecución
	usualmente completan tareas reales y de benchmark en menos tiempo que los supuestos más rápidos, procesadores de mayores frecuencias de clock.

	\section{Tipos de Benchmarks}
	Como se ha mencionado en el apartado anterior existen diferentes tipo de benchmarks que permiten obtener un valor cuantitativo de la performace de un
	componente en diferentes circunstancias de ejecución.
	
		\begin{tabular}{ p{2.5cm} p{8cm} p{3cm} }
		\hline 
		\rowcolor[gray]{0.8} Tipo & Descripción & Ejemplo \\
		\hline
		De programas reales  &  Diseñados para evaluar el rendimiento de el procesador en aplicaciones de uso cotidiano: procesadores de texto
		como \LaTeX, software de diseño asistido por computadora (CAD) y aplicaciones generales de usuario & SPECint y SPECfp\\
		\hline
		Microbenchmark  &  Diseñados para medir la performance de una pequeña y específica porción de código \\
		\hline
		Kernel			&  Se basan en el análisis y conocimiento de que en la mayoría de los casos solo el 10 \% del código ejecutado utiliza el 80\% de los
		recursos de CPU utilizando estas porciones de código clave para realizar el benchmark.\cite{EtiquetaBM01} & linpack y livermore loops\\
		\hline
		Benchmark de componentes & Programas diseñados para medir la performance de componentes básicos. Detectan automáticamente parametros de hardware
		como el numero de registros, tamaño de cache, latencia de memoria,etc. &  SPEC CPU2006\\
		\hline
		Benchmarks Sintéticos  &  Diseñados para medir la performance de una pequeña y específica porción de código & Whetstone y Dhrystone\\
		\hline
		Benchmarks I/O  &  Utilizados para medir la performace de los dispositivos de entrada y salida & \\
		\hline
		Benchmark de Base de Datos  & Pretenden medir el throughtput y los tiempos de respuesta de los sistemas de gestión de base de datos & Transaction
		Processing Performance Council (TPC)\\
		\hline
		Benchmarks Paralelos  &  Diseñados para ser utilizados en procesadores multicore o sistemas distribuidos & NAS Parallel Benchmarks (NPB)\\
		\hline
		\end{tabular}
	
	\section{Benchmarking de Sistemas Embebidos}
 	
	Surge entonces la necesidad de un Benchmark que permita verificar las prestaciones de Sistemas Embebidos y que proporcione datos estadísticos
	comparables acerca de otros Sistemas Embebidos. El Embedded Microprocessor Benchmark Consortium (EEMBC) desarrolló una serie de aplicaciones
	benchmark que facilitan a los diseñadores de sistemas la selección de los procesadores óptimos para sus desarrollos. EEMBC organiza su conjunto de
	benchmarks apuntando a diferentes ramas de aplicación tales como Automotriz, Sistemas Digitales, Java, Procesadores Multicore, Redes, Procesamiento
	de señales, Smartphones/tablets y Browsers.
	
	A pesar de que no se corresponde con la forma en que se utilizaría un procesador ejecutando una aplicación real, a veces es importante aislar el
 	núcleo de la CPU de los otros elementos del procesador y centrarse en este elemento clave. Es posible, por ejemplo,  que desee tener la capacidad de
 	hacer caso omiso de la memoria y los efectos de E/S con el fin de focalizar el análisis principalmente en la operación de un pipeline. 

	\section{CoreMark}	
	CoreMark es un Benchmark que pretende medir la performance de las CPU utilizadas en Sistemas Embebidos. Fue desarrollado en 2009 por Shay Gal-On en
	el EEMBC y se ha convertido un estándar de facto de la industria llegando a reemplazar al antiguo benchmark Dhrystone. CoreMark esta desarrollado en
	C y contiene implementaciones de los siguientes algoritmos:
	
	\begin{itemize}
	\item Procesamiento de listas (Find and sort)
	\item Manipulación de matrices (Operaciones comunes de matrices)
	\item Máquina de estados 
	\item Códigos de redundancia cíclica (CRC)  
	\end{itemize}	 
	
	Las actuales plataformas con procesadores embebidos no solo están compuestas por un CPU y un subsistema de memoria. De hecho, los SoC pueden estar
	compuestos por más de un núcleo de CPU, aceleradores de hardware, periféricos complejos y grandes cantidades de memoria. CoreMark es el punto de
	partida para la evaluación de éstos dispositivos complejo. El benchmark es capaz de probar la estructura de pipeline básica de un procesador, así
	como la capacidad de prueba de lectura/escritura de operaciones básicas, operaciones de enteros y operaciones de control. Respecto de los periféricos
	y mecanismos de interrupción el EEMBC desarrolla una colección de tests basados en escenarios y conducidos por hardware que evalúan dichos
	periféricos y la capacidad del CPU de prestar servicio a los mismos y a otras interrupciones a nivel sistema.
	
	Los resultados del Benchmark pueden ser encontrados en la página principal del proyecto y se presentan en el siguiente formato:
	
	CoreMark 1.0 : N / C [/ P] [/ M]
	
	Donde:
	\begin{itemize}
	\item N: Numero de iteraciones por segundo 
	\item C: Versión del compilador y flags
	\item P: Parámetros específicos de memoria y datos
	\item M: Tipo de ejecución de algoritmo paralelo y el numero de contextos.
	\end{itemize}	 
	
	Por ejemplo: CoreMark 1.0 : 128 / GCC 4.1.2 -O2 -fprofile-use / Heap in TCRAM / FORK:2
	
 	


